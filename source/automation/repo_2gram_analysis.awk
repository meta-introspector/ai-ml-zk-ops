#!/usr/bin/awk -f
#
# Filename: repo_2gram_analysis.awk
# Description: This script performs a 2-gram analysis on repository names extracted from file paths.
#              It identifies repository owner/name pairs from paths matching the pattern
#              "./source/tools/github/<owner>/<repo>/..." and counts their occurrences.
#              The output is a list of 2-grams (owner repo) and their frequencies,
#              sorted in descending order of frequency, formatted as CSV.
#
# Usage:
#   awk -f repo_2gram_analysis.awk <input_file>
#
# Input:
#   A file where each line is a file path, typically generated by 'find' or similar.
#   Example line: "./source/tools/github/meta-introspector/git-submodule-tools-rs/file.txt"
#
# Output:
#   CSV formatted lines in the format "Count,Owner,Repo", e.g., "10,meta-introspector,git-submodule-tools-rs"
#
# Nix Flakes Context:
#   This script interprets file paths as originating from vendored GitHub repositories,
#   a common practice in Nix flakes for managing external dependencies. The extracted
#   "owner repo" 2-grams directly correspond to the components of a GitHub flake input
#   (e.g., "github:owner/repo"). This analysis helps in understanding the most frequently
#   referenced external repositories within the project's file structure, which can
#   inform dependency management and flake optimization efforts.
#
BEGIN {
  FS="/";      # Set field separator to '/' to split paths into components
  # OFS is not explicitly set here as we construct the CSV line manually in END
}

# Arrays to store counts, owners, and repos, indexed by a unique key (owner_repo)
# This allows us to reconstruct the owner and repo for CSV output.
# counts[key] stores the frequency
# owners[key] stores the owner name
# repos[key] stores the repository name

/source\/tools\/github\// {
  github_idx = 0; # Initialize index for "github" component

  # Find the array index of the "github" component in the path
  for (i=1; i<=NF; i++) {
    if ($i == "github") {
      github_idx = i;
      break;
    }
  }

  # If "github" is found and there are at least two more components (owner and repo)
  if (github_idx > 0 && (github_idx + 2) <= NF) {
    owner_val = $(github_idx + 1); # The component after "github" is the owner
    repo_val = $(github_idx + 2);  # The component after owner is the repository name

    # Ensure both owner and repo are not empty
    if (owner_val != "" && repo_val != "") {
      key = owner_val "_" repo_val; # Create a unique key for this owner/repo pair
      counts[key]++;                # Increment the count for this pair
      owners[key] = owner_val;      # Store the owner name
      repos[key] = repo_val;        # Store the repository name
    }
  }
}

END {
  print "Count,Owner,Repo"; # Print CSV Header

  # Iterate through all collected unique keys and print their counts, owner, and repo in CSV format
  for (key in counts) {
    print counts[key] "," owners[key] "," repos[key];
  }
}